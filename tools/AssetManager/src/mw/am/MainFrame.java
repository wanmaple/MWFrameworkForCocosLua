/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package mw.am;

import com.alibaba.fastjson.JSONObject;
import java.awt.Color;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JScrollBar;
import javax.swing.SwingUtilities;

/**
 *
 * @author Maple
 */
public class MainFrame extends javax.swing.JFrame {

    /**
     * Creates new form MainFrame
     */
    public MainFrame() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        fileChooser = new javax.swing.JFileChooser();
        buttonGroup1 = new javax.swing.ButtonGroup();
        btnLoad = new javax.swing.JButton();
        txtLoadPath = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        lblCurrentVersion = new javax.swing.JLabel();
        btnAsset = new javax.swing.JButton();
        txtAssetPath = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        txtGitSha = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        ddlVersion4 = new javax.swing.JComboBox();
        jLabel4 = new javax.swing.JLabel();
        lblNewVersion = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        txtUpdateUrl = new javax.swing.JTextField();
        svLog = new javax.swing.JScrollPane();
        txtLog = new javax.swing.JTextArea();
        btnGenerate = new javax.swing.JButton();
        rbVersion1 = new javax.swing.JRadioButton();
        rbVersion2 = new javax.swing.JRadioButton();
        rbVersion3 = new javax.swing.JRadioButton();
        rbVersion4 = new javax.swing.JRadioButton();
        jLabel5 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        lblCurrentCppVersion = new javax.swing.JLabel();
        lblNewCppVersion = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Asset Manager");
        setResizable(false);

        btnLoad.setText("版本库目录");
        btnLoad.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnLoadActionPerformed(evt);
            }
        });

        jLabel1.setText("当前版本");

        btnAsset.setText("游戏包目录");
        btnAsset.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAssetActionPerformed(evt);
            }
        });

        jLabel2.setText("GIT提交SHA码(前6位)");

        txtGitSha.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                txtGitShaFocusLost(evt);
            }
        });
        txtGitSha.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                txtGitShaActionPerformed(evt);
            }
        });

        jLabel3.setText("版本类型");

        ddlVersion4.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "DEVELOP", "ALPHA", "BETA", "RELEASE" }));
        ddlVersion4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ddlVersion4ActionPerformed(evt);
            }
        });

        jLabel4.setText("新版本号");

        lblNewVersion.setForeground(new java.awt.Color(255, 0, 0));
        lblNewVersion.setToolTipText("");

        jLabel6.setText("C++更新地址");

        txtUpdateUrl.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                txtUpdateUrlFocusLost(evt);
            }
        });
        txtUpdateUrl.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                txtUpdateUrlActionPerformed(evt);
            }
        });

        txtLog.setColumns(20);
        txtLog.setRows(5);
        txtLog.setFocusable(false);
        svLog.setViewportView(txtLog);

        btnGenerate.setText("生成");
        btnGenerate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGenerateActionPerformed(evt);
            }
        });

        buttonGroup1.add(rbVersion1);
        rbVersion1.setText("主版本更新");
        rbVersion1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbVersion1ActionPerformed(evt);
            }
        });

        buttonGroup1.add(rbVersion2);
        rbVersion2.setText("次版本更新");
        rbVersion2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbVersion2ActionPerformed(evt);
            }
        });

        buttonGroup1.add(rbVersion3);
        rbVersion3.setSelected(true);
        rbVersion3.setText("小版本更新");
        rbVersion3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbVersion3ActionPerformed(evt);
            }
        });

        buttonGroup1.add(rbVersion4);
        rbVersion4.setText("先行版本更新");
        rbVersion4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbVersion4ActionPerformed(evt);
            }
        });

        jLabel5.setText("当前C++版本");

        jLabel7.setText("新C++版本");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(btnLoad)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(txtLoadPath))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(btnAsset)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(txtAssetPath))
                    .addComponent(svLog, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(btnGenerate))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(rbVersion1)
                        .addGap(18, 18, 18)
                        .addComponent(rbVersion2)
                        .addGap(18, 18, 18)
                        .addComponent(rbVersion3)
                        .addGap(18, 18, 18)
                        .addComponent(rbVersion4))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(6, 6, 6)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel6)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(txtUpdateUrl))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(txtGitSha, javax.swing.GroupLayout.PREFERRED_SIZE, 127, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addComponent(jLabel3)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(ddlVersion4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addGap(18, 18, 18)
                                .addComponent(lblCurrentVersion)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jLabel5)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(lblCurrentCppVersion)
                                .addGap(60, 60, 60))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel4)
                                .addGap(18, 18, 18)
                                .addComponent(lblNewVersion)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jLabel7)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(lblNewCppVersion)
                                .addGap(61, 61, 61)))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(rbVersion1)
                    .addComponent(rbVersion2)
                    .addComponent(rbVersion3)
                    .addComponent(rbVersion4))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnLoad)
                    .addComponent(txtLoadPath, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(lblCurrentVersion)
                    .addComponent(jLabel5)
                    .addComponent(lblCurrentCppVersion))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btnAsset)
                    .addComponent(txtAssetPath, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(txtGitSha, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel3)
                    .addComponent(ddlVersion4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(lblNewVersion)
                    .addComponent(jLabel7)
                    .addComponent(lblNewCppVersion))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel6)
                    .addComponent(txtUpdateUrl, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(svLog, javax.swing.GroupLayout.DEFAULT_SIZE, 172, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnGenerate)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnLoadActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnLoadActionPerformed
        // TODO add your handling code here:
        fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        try {
            fileChooser.setSelectedFile(new File(".").getCanonicalFile());
        } catch (IOException ex) {
            Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
        int result = fileChooser.showOpenDialog(this);
        if (result == JFileChooser.APPROVE_OPTION) {
            String path = fileChooser.getSelectedFile().getAbsolutePath();
            txtLoadPath.setText(path);
            this.checkAssetPath();
        }
    }//GEN-LAST:event_btnLoadActionPerformed

    private void btnAssetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAssetActionPerformed
        // TODO add your handling code here:
        fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        try {
            fileChooser.setSelectedFile(new File(".").getCanonicalFile());
        } catch (IOException ex) {
            Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
        int result = fileChooser.showOpenDialog(this);
        if (result == JFileChooser.APPROVE_OPTION) {
            String path = fileChooser.getSelectedFile().getAbsolutePath();
            txtAssetPath.setText(path);
        }
    }//GEN-LAST:event_btnAssetActionPerformed

    private void txtGitShaFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_txtGitShaFocusLost
        // TODO add your handling code here:
        this.updateNewVersionNumber();
    }//GEN-LAST:event_txtGitShaFocusLost

    private void txtGitShaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_txtGitShaActionPerformed
        // TODO add your handling code here:
        this.updateNewVersionNumber();
    }//GEN-LAST:event_txtGitShaActionPerformed

    private void ddlVersion4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ddlVersion4ActionPerformed
        // TODO add your handling code here:
        this.updateNewVersionNumber();
    }//GEN-LAST:event_ddlVersion4ActionPerformed

    private void rbVersion1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbVersion1ActionPerformed
        // TODO add your handling code here:
        this.updateNewVersionNumber();
    }//GEN-LAST:event_rbVersion1ActionPerformed

    private void rbVersion2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbVersion2ActionPerformed
        // TODO add your handling code here:
        this.updateNewVersionNumber();
    }//GEN-LAST:event_rbVersion2ActionPerformed

    private void rbVersion3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbVersion3ActionPerformed
        // TODO add your handling code here:
        this.updateNewVersionNumber();
    }//GEN-LAST:event_rbVersion3ActionPerformed

    private void rbVersion4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbVersion4ActionPerformed
        // TODO add your handling code here:
        this.updateNewVersionNumber();
    }//GEN-LAST:event_rbVersion4ActionPerformed

    private void btnGenerateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGenerateActionPerformed
        // TODO add your handling code here:
        if (txtLoadPath.getText().trim().isEmpty()) {
            JOptionPane.showMessageDialog(this, "请选择版本库目录。");
            return;
        }
        if (txtAssetPath.getText().trim().isEmpty()) {
            JOptionPane.showMessageDialog(this, "请选择游戏包目录。");
            return;
        }
        String loadPath = txtLoadPath.getText().trim();
        String assetPath = txtAssetPath.getText().trim();
        if (!new File(loadPath).exists() || !new File(loadPath).isDirectory()) {
            JOptionPane.showMessageDialog(this, "不存在或无效的版本库目录。");
            return;
        }
        if (!new File(assetPath).exists() || !new File(assetPath).isDirectory()) {
            JOptionPane.showMessageDialog(this, "不存在或无效的游戏包目录。");
            return;
        }
        if (txtGitSha.getText().trim().isEmpty()) {
            JOptionPane.showMessageDialog(this, "请填写Git Sha。");
            return;
        }
        
        String newVersion = lblNewVersion.getText();
        String cppUpdateUrl = txtUpdateUrl.getText().trim();
        int result = JOptionPane.showConfirmDialog(this, String.format("新版本号为: %s\ncpp更新地址为: %s\n请再次确认信息后点击确定。", newVersion, cppUpdateUrl));
        if (result == JOptionPane.OK_OPTION) {
            new Runnable() {
                @Override
                public void run() {
                    log("开始生成...");
                    copyNewAsset();
                    calculateMd5();
                    if (!generateConfig()) return;
                    if (!generateBundleMd5()) return;
                    if (!generateChangeLog()) return;
                    if (!generateVersionFile()) return;
                    generateUploadFiles();
                    checkAssetPath();
                    log("生成完毕");
                }
            }.run();
        }
    }//GEN-LAST:event_btnGenerateActionPerformed

    private void txtUpdateUrlActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_txtUpdateUrlActionPerformed
        // TODO add your handling code here:
        this.updateNewVersionNumber();
    }//GEN-LAST:event_txtUpdateUrlActionPerformed

    private void txtUpdateUrlFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_txtUpdateUrlFocusLost
        // TODO add your handling code here:
        this.updateNewVersionNumber();
    }//GEN-LAST:event_txtUpdateUrlFocusLost

    private void copyNewAsset() {
        this.log("正在拷贝新版本到版本库...");
        
        String loadPath = txtLoadPath.getText().trim();
        String assetPath = txtAssetPath.getText().trim();
        String newVersion = lblNewVersion.getText();
        
        String historyDir = FileUtils.getInstance().splicePath(loadPath, HISTORY_DIR, newVersion);
        
        FileUtils.getInstance().copyDirectory(assetPath, historyDir);
    }
    
    private void calculateMd5() {
        this.log("正在计算文件的MD5值...");
        
        String loadPath = txtLoadPath.getText().trim();
        String assetPath = txtAssetPath.getText().trim();
        String oldVersion = lblCurrentVersion.getText();
        
        // 重置文件变化信息
        _addList = new ArrayList<>();
        _removeList = new ArrayList<>();
        _modifyList = new ArrayList<>();
        _oldMd5Map = new HashMap<>();
        _newMd5Map = new HashMap<>();
        _fileSizeMap = new HashMap<>();
        
        // 旧的md5目录
        String oldMd5Dir = FileUtils.getInstance().splicePath(loadPath, MD5_DIR, oldVersion);
        String oldMd5Path = FileUtils.getInstance().splicePath(oldMd5Dir, BUNDLE_MD5_FILE);
        // 如果旧文件存在 则初始化old md5 map
        if (new File(oldMd5Path).exists()) {
            String content = new String(FileUtils.getInstance().readDataFromFile(oldMd5Path));
            JSONObject jsonObj = JSONObject.parseObject(content);
            Set<String> keys = jsonObj.keySet();
            for (String key : keys) {
                _oldMd5Map.put(key, jsonObj.getString(key));
            }
        }
        
        File hAsset = new File(assetPath);
        // 计算文件大小map
        for (File f : hAsset.listFiles()) {
            this.generateFileSizeForEachFile(_fileSizeMap, f, "");
        }
        
        // 计算new md5 map
        for (File f : hAsset.listFiles()) {
            this.generateMd5ForEachFile(_newMd5Map, f, "", 0);
        }
        // 计算文件变化
        Set<String> oldMd5Keys = _oldMd5Map.keySet();
        for (String key : oldMd5Keys) {
            if (!_newMd5Map.containsKey(key)) {
                _removeList.add(key);
            }
        }
        Set<String> newMd5Keys = _newMd5Map.keySet();
        for (String key: newMd5Keys) {
            if (!_oldMd5Map.containsKey(key)) {
                _addList.add(key);
            } else if (!_oldMd5Map.get(key).equals(_newMd5Map.get(key))) {
                _modifyList.add(key);
            }
        }
    }
    
    private boolean generateConfig() {
        this.log("正在生成配置文件...");
        
        String loadPath = txtLoadPath.getText().trim();
        
        // 生成配置json
        JSONObject configJsonObj = new JSONObject();
        configJsonObj.put(FILE_COUNT_KEY, _newMd5Map.keySet().size());
        // 文件信息json
        JSONObject fileInfoJsonObj = new JSONObject();
        Set<String> keys = _fileSizeMap.keySet();
        for (String key : keys) {
            fileInfoJsonObj.put(key, _fileSizeMap.get(key));
        }
        configJsonObj.put(FILE_INFO_KEY, fileInfoJsonObj);
        
        String configPath = FileUtils.getInstance().splicePath(loadPath, ASSET_CONFIG_FILE);
        boolean success = FileUtils.getInstance().writeDataToFile(configPath, configJsonObj.toJSONString().getBytes());
        if (!success) {
            this.log("生成配置文件失败...");
        }
        
        return success;
    }
    
    private boolean generateBundleMd5() {
        this.log("正在生成Bundle Md5文件...");
        
        String loadPath = txtLoadPath.getText().trim();
        String newVersion = lblNewVersion.getText();
        // 新的md5目录
        String newMd5Dir = FileUtils.getInstance().splicePath(loadPath, MD5_DIR, newVersion);
        // 创建新的md5目录和文件
        FileUtils.getInstance().createDirectory(newMd5Dir);
        
        JSONObject newMd5JsonObj = new JSONObject();
        Set<String> keys = _newMd5Map.keySet();
        for (String key : keys) {
            newMd5JsonObj.put(key, _newMd5Map.get(key));
        }
        String newMd5Path = FileUtils.getInstance().splicePath(newMd5Dir, BUNDLE_MD5_FILE);
        boolean success = FileUtils.getInstance().writeDataToFile(newMd5Path, newMd5JsonObj.toJSONString().getBytes());
        if (!success) {
            this.log("生成Bundle Md5文件失败");
        }
        
        return success;
    }
    
    private boolean generateChangeLog() {
        this.log("正在生成日志文件...");
        
        String loadPath = txtLoadPath.getText().trim();
        String oldVersion = lblCurrentVersion.getText();
        String newVersion = lblNewVersion.getText();
        
        // 日志目录
        String logDir = FileUtils.getInstance().splicePath(loadPath, CHANGE_LOG_DIR);
        if (!new File(logDir).exists()) {
            FileUtils.getInstance().createDirectory(logDir);
        }
        // 文件名: "老版本号-新版本号
        if (oldVersion.equals("当前无版本")) {
            oldVersion = "none";
        }
        String logPath = FileUtils.getInstance().splicePath(logDir, oldVersion + "-" + newVersion + ".txt");
        
        // 日志内容
        int total = _addList.size() + _removeList.size() + _modifyList.size();
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("Total: %d    Add: %d    Modify: %d    Delete: %d\r\n\r\n", total, _addList.size(), _modifyList.size(), _removeList.size()));
        for (String content : _addList) {
            sb.append(String.format("A\t%s\r\n", content));
        }
        for (String content : _modifyList) {
            sb.append(String.format("M\t%s\r\n", content));
        }
        for (String content : _removeList) {
            sb.append(String.format("D\t%s\r\n", content));
        }
        // 写入文件
        boolean success = FileUtils.getInstance().writeDataToFile(logPath, sb.toString().getBytes());
        if (!success) {
            this.log("生成Log文件失败");
        }
        
        return success;
    }
    
    private boolean generateVersionFile() {
        this.log("正在生成版本文件...");
        
        String loadPath = txtLoadPath.getText().trim();
        String newVersion = lblNewVersion.getText();
        
        // 生成版本json文件
        JSONObject versionJsonObj = new JSONObject();
        versionJsonObj.put(VERSION1_KEY, _newVersion1);
        versionJsonObj.put(VERSION2_KEY, _newVersion2);
        versionJsonObj.put(VERSION3_KEY, _newVersion3);
        versionJsonObj.put(VERSION4_KEY, _newVersion4);
        versionJsonObj.put(VERSION_TYPE_KEY, _newVersionType);
        versionJsonObj.put(CPP_VERSION_KEY, _newCppVersion);
        versionJsonObj.put(SHA_CODE_KEY, _newSha);
        versionJsonObj.put(VERSION_STR_KEY, newVersion);
        versionJsonObj.put(CPP_UPDATE_URL_KEY, txtUpdateUrl.getText().trim());
        
        String versionPath = FileUtils.getInstance().splicePath(loadPath, VERSION_FILE);
        boolean success = FileUtils.getInstance().writeDataToFile(versionPath, versionJsonObj.toString().getBytes());
        if (!success) {
            this.log("生成版本文件失败");
        }
        
        return success;
    }
    
    private void generateUploadFiles() {
        this.log("正在生成需要上传的文件...");
        
        String loadPath = txtLoadPath.getText().trim();
        String assetPath = txtAssetPath.getText().trim();
        String newVersion = lblNewVersion.getText();
        
        // 创建upload目录
        String uploadDir = FileUtils.getInstance().splicePath(loadPath, UPLOAD_DIR);
        if (!new File(uploadDir).exists()) {
            FileUtils.getInstance().createDirectory(uploadDir);
        }
        FileUtils.getInstance().removeDirectory(uploadDir);
        // 拷贝版本文件
        String versionPath = FileUtils.getInstance().splicePath(loadPath, VERSION_FILE);
        FileUtils.getInstance().copyFile(versionPath, FileUtils.getInstance().splicePath(uploadDir, VERSION_FILE));
        // 拷贝配置文件
        String configPath = FileUtils.getInstance().splicePath(loadPath, ASSET_CONFIG_FILE);
        FileUtils.getInstance().copyFile(configPath, FileUtils.getInstance().splicePath(uploadDir, ASSET_CONFIG_FILE));
        // 拷贝md5文件
        String md5Path = FileUtils.getInstance().splicePath(loadPath, MD5_DIR, newVersion, BUNDLE_MD5_FILE);
        FileUtils.getInstance().copyFile(md5Path, FileUtils.getInstance().splicePath(uploadDir, MD5_DIR, newVersion, BUNDLE_MD5_FILE));
        // 拷贝增量资源包
        String assetDir = FileUtils.getInstance().splicePath(uploadDir, ASSET_DIR);
        FileUtils.getInstance().removeAllFiles(assetDir);
        if (!new File(assetDir).exists()) {
            FileUtils.getInstance().createDirectory(uploadDir);
        }
        for (String file : _addList) {
            FileUtils.getInstance().copyFile(FileUtils.getInstance().splicePath(assetPath, file), FileUtils.getInstance().splicePath(assetDir, file.replace('/', File.separatorChar)));
        }
        for (String file : _modifyList) {
            FileUtils.getInstance().copyFile(FileUtils.getInstance().splicePath(assetPath, file), FileUtils.getInstance().splicePath(assetDir, file.replace('/', File.separatorChar)));
        }
    }
    
    private int generateMd5ForEachFile(Map<String, String> map, File file, String parentPath, int fileCount) {
        try {
            if (file.isDirectory()) {
                File[] files = file.listFiles();
                for (File f : files) {
                    fileCount = this.generateMd5ForEachFile(map, f, parentPath + file.getName() + File.separator, fileCount);
                }
            } else if (file.isFile()) {
                ++fileCount;
                map.put((parentPath + file.getName()).replace('\\', '/'), Md5Utils.getInstance().getFileMD5String(file));
            }
        } catch (IOException ex) {
            Logger.getLogger(MainFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        return fileCount;
    }
    
    private void generateFileSizeForEachFile(Map<String, Long> map, File file, String parentPath) {
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (File f : files) {
                this.generateFileSizeForEachFile(map, f, parentPath + file.getName() + File.separator);
            }
        } else if (file.isFile()) {
            map.put((parentPath + file.getName()).replace('\\', '/'), file.length());
        }
    }
    
    private void updateNewVersionNumber() {
        if (lblCurrentVersion.getText().isEmpty()) {
            return;
        }
        String newVersion = this.autoVersion();
        lblNewVersion.setText(newVersion);
        String newCppVersion = this.autoCppVersion();
        lblNewCppVersion.setText(newCppVersion);
    }
    
    private void checkAssetPath() {
        String loadPath = txtLoadPath.getText();
        File hLoad = new File(loadPath);
        File[] children = hLoad.listFiles();
        File hVersion = null;
        for (File child : children) {
            if (child.isFile() && child.getName().equals(VERSION_FILE)) {
                hVersion = child;
                break;
            }
        }
        
        if (hVersion != null) {
            String content = new String(FileUtils.getInstance().readDataFromFile(hVersion.getAbsolutePath()));
            JSONObject jsonObj = JSONObject.parseObject(content);
            _version1 = jsonObj.getIntValue(VERSION1_KEY);
            _version2 = jsonObj.getIntValue(VERSION2_KEY);
            _version3 = jsonObj.getIntValue(VERSION3_KEY);
            _version4 = jsonObj.getIntValue(VERSION4_KEY);
            _versionType = jsonObj.getIntValue(VERSION_TYPE_KEY);
            _cppVersion = jsonObj.getIntValue(CPP_VERSION_KEY);
            ddlVersion4.setSelectedIndex(_versionType);
            _sha = jsonObj.getString(SHA_CODE_KEY);
        
            String version = String.format("%d.%d.%d-%s%d.%s", _version1, _version2, _version3, TYPE_CHARS[_versionType], _version4, _sha);
            lblCurrentVersion.setText(version);
            lblCurrentCppVersion.setText(String.valueOf(_cppVersion));
        } else {
            lblCurrentVersion.setText("当前无版本");
            lblCurrentCppVersion.setText("当前无版本");
        }
        this.updateNewVersionNumber();
    }
    
    private String getGitSha() {
        String sha = txtGitSha.getText().trim();
        int len = sha.length();
        if (len > 6) {
            sha = sha.substring(0, 6);
        } else if (len < 6) {
            for (int i = 0; i < 6 - len; i++) {
                sha += "0";
            }
        }
        return sha.toUpperCase();
    }
    
    private String autoVersion() {
        int version1 = _version1;
        int version2 = _version2;
        int version3 = _version3;
        String versionType = TYPE_CHARS[ddlVersion4.getSelectedIndex()];
        int version4 = _version4;
        String sha = this.getGitSha();
        if (rbVersion1.isSelected()) {
            ++version1;
            version2 = version3 = 0;
        } else if (rbVersion2.isSelected()) {
            ++version2;
            version3 = 0;
        } else if (rbVersion3.isSelected()) {
            ++version3;
        } else if (rbVersion4.isSelected()) {
            ++version4;
        }
        if (_versionType != ddlVersion4.getSelectedIndex()) {
            version4 = 0;
        }
        String version = String.format("%d.%d.%d-%s%d.%s", version1, version2, version3, versionType, version4, sha);
        
        this._newVersion1 = version1;
        this._newVersion2 = version2;
        this._newVersion3 = version3;
        this._newVersion4 = version4;
        this._newVersionType = ddlVersion4.getSelectedIndex();
        this._newSha = sha;
        
        return version;
    }
    
    private String autoCppVersion() {
        _newCppVersion = _cppVersion;
        String cppUpdateUrl = txtUpdateUrl.getText().trim();
        if (!cppUpdateUrl.isEmpty() && !lblCurrentCppVersion.getText().equals("当前无版本")) {
            ++_newCppVersion;
            lblNewCppVersion.setForeground(Color.RED);
        } else {
            lblNewCppVersion.setForeground(Color.BLACK);
        }
        return String.valueOf(_newCppVersion);
    }
    
    private void log(String content) {
        _contents.offer(content);
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                String msg = _contents.poll();
                txtLog.append(msg + "\n");
                JScrollBar scrollBar = svLog.getVerticalScrollBar();
                if (scrollBar != null) {
                    scrollBar.setValue(scrollBar.getMaximum());
                }
            }
        });
    }
    
    // 版本号相关
    private final int DEVELOP_TYPE = 0;
    private final int ALPHA_TYPE = DEVELOP_TYPE + 1;
    private final int BETA_TYPE = ALPHA_TYPE + 1;
    private final int RELEASE_TYPE = BETA_TYPE + 1;
    private final String[] TYPE_CHARS = { "D", "A", "B", "R" };
    private final String VERSION1_KEY = "version1";
    private final String VERSION2_KEY = "version2";
    private final String VERSION3_KEY = "version3";
    private final String VERSION4_KEY = "version4";
    private final String VERSION_TYPE_KEY = "version_type";
    private final String CPP_VERSION_KEY = "cpp_version";
    private final String SHA_CODE_KEY = "sha_code";
    private final String VERSION_STR_KEY = "version_str";
    private final String CPP_UPDATE_URL_KEY = "cpp_update_url";
    private final String FILE_COUNT_KEY = "file_count";
    private final String FILE_INFO_KEY = "file_info";
    // 版本库目录相关
    private final String HISTORY_DIR = "History";   // 历史版本
    private final String CHANGE_LOG_DIR = "ChangeLog";   // 和上个版本的差异信息
    private final String MD5_DIR = "BundleMd5";     // 文件md5信息
    private final String UPLOAD_DIR = "Upload";     // 需要上传到服务器的文件生成在这里
    private final String ASSET_DIR = "Asset";   // Upload下的子目录
    private final String BUNDLE_MD5_FILE = "bundle_md5.json";   // md5文件
    private final String VERSION_FILE = "version.json";    // 版本文件
    private final String ASSET_CONFIG_FILE = "config.json";     // 配置文件
    // 记录文件变化信息
    private List<String> _addList = null;
    private List<String> _removeList = null;
    private List<String> _modifyList = null;
    private Map<String, String> _oldMd5Map = null;
    private Map<String, String> _newMd5Map = null;
    private Map<String, Long> _fileSizeMap = null;
    
    private int _versionType = -1;   // 
    private int _version1 = 0;      // 主版本号
    private int _version2 = 0;      // 次版本号
    private int _version3 = 0;      // 普通版本号
    private int _version4 = 0;      // 先行版本号
    private int _cppVersion = 0;    // cpp版本
    private String _sha = "000000";       // git sha(前6位)
    
    private int _newVersionType;
    private int _newVersion1;
    private int _newVersion2;
    private int _newVersion3;
    private int _newVersion4;
    private int _newCppVersion;
    private String _newSha;
    
    private final Queue<String> _contents = new LinkedList<>();
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new MainFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnAsset;
    private javax.swing.JButton btnGenerate;
    private javax.swing.JButton btnLoad;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JComboBox ddlVersion4;
    private javax.swing.JFileChooser fileChooser;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel lblCurrentCppVersion;
    private javax.swing.JLabel lblCurrentVersion;
    private javax.swing.JLabel lblNewCppVersion;
    private javax.swing.JLabel lblNewVersion;
    private javax.swing.JRadioButton rbVersion1;
    private javax.swing.JRadioButton rbVersion2;
    private javax.swing.JRadioButton rbVersion3;
    private javax.swing.JRadioButton rbVersion4;
    private javax.swing.JScrollPane svLog;
    private javax.swing.JTextField txtAssetPath;
    private javax.swing.JTextField txtGitSha;
    private javax.swing.JTextField txtLoadPath;
    private javax.swing.JTextArea txtLog;
    private javax.swing.JTextField txtUpdateUrl;
    // End of variables declaration//GEN-END:variables
}
